compilers parsers interpreters type-systems type-inference dependent-types linear-types effect-systems HM hindley-milner bidirectional-typechecking polymorphism generics monomorphization existential-types GADTs algebraic-data-types pattern-matching lambda-calculus simply-typed-lambda-calculus system-f curry-howard abstract-syntax-trees SSA static-single-assignment control-flow-graph dataflow-analysis register-allocation instruction-selection code-generation LLVM cranelift JIT bytecode virtual-machines GC garbage-collection reference-counting tracing-GC incremental-GC concurrent-GC memory-management ownership-borrow-checker lifetimes affine-types substructural-types semantics operational-semantics denotational-semantics small-step big-step evaluation-strategies lazy-evaluation strict-evaluation call-by-value call-by-need closures continuations CPS monads functors applicatives algebraic-effects macro-systems hygiene procedural-macros syntax-extension metaprogramming reflection runtime-codegen trait-systems typeclasses higher-kinded-types row-polymorphism extensible-records modules ML-modules OCaml SML Haskell Rust Zig Nim Gleam Lean Agda Idris Coq formal-semantics mechanized-metatheory PLT gradual-typing refinement-types theorem-proving proof-assistants compiler-correctness verified-compilation CompCert
